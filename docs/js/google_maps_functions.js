//Returns a container with both a map and heatmap layer to be used for visualization. Must be assigned to a spot in the html
function InitNewMap(center_lat, center_long, html_map_element)
{
	var mapData = {
		map: new google.maps.Map(html_map_element, {
			zoom: 18,
			center: {lat: center_lat, lng: center_long},
			mapTypeId: 'satellite'
		}),
		heatmap: null
		//Additional fields here as needed
	};
	return mapData;
}

//Loads breadcrumbs from the given CSV and parses them into an array where each element is an object in the following format:
//id:[int]	surveyID:[string]	time_date:[string]	time_time:[string]	lat:[float]	lng:[float]	accuracy:[float]	speed:[float]
//Once the array is complete, it is passed as the only parameter to onLoadFunction.
//Note that this function will run asynchronously
function LoadBreadcrumbsFromFile(file, onLoadFunction)
{
	var reader = new FileReader();
	var func = function(e){
		var text = reader.result;
		onLoadFunction(LoadBreadcrumbsFromString(text));
	}
	reader.onload = func;
	reader.readAsText(file);
}

function LoadBreadcrumbsFromString(text)
{
	text = text.split('\n');
	text.splice(0, 1);//first line is labels
	for(var i = 0;i < text.length;i++)
	{
		if(text[i].length == 0)//blank line, remove it and try again
		{
			text.splice(i, 1);
			i--;
		}
		else
		{	
			var values = ParseCSVLine(text[i]);
			
			text[i] = {
				_id: parseInt(values[0]),
				surveyID: values[1],
				time_date: values[2],
				time_time: values[3],
				lat: parseFloat(values[4]),
				lng: parseFloat(values[5]),
				accuracy: parseFloat(values[6]),
				speed: parseFloat(values[7])
			};
		}
	}
	return text;
}

function LoadSightingsFromFile(file, onLoadFunction)
{
	var reader = new FileReader();
	var func = function(e){
		var text = reader.result;
		
		onLoadFunction(LoadSightingsFromString(text));
	}
	reader.onload = func;
	reader.readAsText(file);
}

function LoadSightingsFromString(text)
{
	text = text.split('\n');
	text.splice(0, 1);//first line is labels
	for(var i = 0;i < text.length;i++)
	{
		if(text[i].length == 0)//blank line, remove it and try again
		{
			text.splice(i, 1);
			i--;
		}
		else
		{	
			var values = ParseCSVLine(text[i]);
			
			text[i] = {
				_id: parseInt(values[0]),
				surveyID: values[1],
				speciesCommon: values[2],
				speciesScientific: values[3],
				subfamilyCommon: values[4],
				subfamilyScientific: values[5],
				familyCommon: values[6],
				familyScientific: values[7],
				number: parseInt(values[8]),
				temperature: parseFloat(values[9]),
				windSpeed: values[10],
				windDirection: values[11],
				cloudCover: values[12],
				time_date: values[13],
				time_time: values[14],
				behavior: values[15],
				gender: values[16],
				condition: values[17],
				comment: values[18],
				transect: values[19],
				photoName: values[20],
				pressure: parseFloat(values[21]),
				ambientTemperature: values[22],
				illuminance: parseFloat(values[23]),
				relativeHumidity: values[24],
				wingLength: values[25],
				markFound: values[26],
				markAdded: values[27],
				lat: parseFloat(values[28]),
				lng: parseFloat(values[29]),
				locationTime_date: values[30],
				locationTime_time: values[31],
				locationAccuracy: parseFloat(values[32]),
				point: values[33],
				certainty: values[34],
				voucherID: values[35],
				voucherType: values[36],
				voucherLocation: values[37]
			};
		}
	}
	return text;
}

//Takes a string and returns an array of its contained values. Values must be comma separated and surrounded by quotation marks
//Quotation marks will not be included in the result
function ParseCSVLine(line)
{
    var re_valid = /^\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^,'"\s\\]*(?:\s+[^,'"\s\\]+)*)\s*(?:,\s*(?:'[^'\\]*(?:\\[\S\s][^'\\]*)*'|"[^"\\]*(?:\\[\S\s][^"\\]*)*"|[^,'"\s\\]*(?:\s+[^,'"\s\\]+)*)\s*)*$/;
    var re_value = /(?!\s*$)\s*(?:'([^'\\]*(?:\\[\S\s][^'\\]*)*)'|"([^"\\]*(?:\\[\S\s][^"\\]*)*)"|([^,'"\s\\]*(?:\s+[^,'"\s\\]+)*))\s*(?:,|$)/g;
    // Return NULL if input string is not well formed CSV string.
    if (!re_valid.test(line)) return null;
    var a = [];                     // Initialize array to receive values.
    line.replace(re_value, // "Walk" the string using replace with callback.
        function(m0, m1, m2, m3) {
            // Remove backslash from \' in single quoted values.
            if      (m1 !== undefined) a.push(m1.replace(/\\'/g, "'"));
            // Remove backslash from \" in double quoted values.
            else if (m2 !== undefined) a.push(m2.replace(/\\"/g, '"'));
            else if (m3 !== undefined) a.push(m3);
            return ''; // Return empty string.
        });
    // Handle special case of empty last value.
    if (/,\s*$/.test(line)) a.push('');
    return a;
}

//Generates an action to be passed into LoadBreadcrumbsFromFile.
//The returned action will apply the breadcrumbs generated by LoadBreadcrumbsFromFile to the map passed into this function as well as a view radius.
function MapBreadcrumbsToMapAction(map)
{
	return function(breadcrumbs){
		//Add proto polygons and lines
		var pathCoordinates = [];
		for(var i = 0;i < breadcrumbs.length;i++)
		{
			// var marker = new google.maps.Marker({//Mark the breadcrumb
				// position: {lat: breadcrumbs[i].lat, lng: breadcrumbs[i].lng},
				// map: map,
				// title: breadcrumbs[i]._id.toString()
			// });
			
			pathCoordinates.push({lat: breadcrumbs[i].lat, lng: breadcrumbs[i].lng});//Add breadcrumb to the path
			
			// new google.maps.Circle({
				// strokeColor: '#FF0000',
				// strokeOpacity: 0.0,
				// strokeWeight: 2,
				// fillColor: '#FF0000',
				// fillOpacity: 0.25,
				// map: map,
				// center: pathCoordinates[pathCoordinates.length-1],
				// radius: 10
			// });
		}
		
		var surveyPath = new google.maps.Polyline({//Draw the path
			path: pathCoordinates,
			geodesic: true,
			strokeColor: '#FF0000',
			strokeOpacity: 1.0,
			strokeWeight: 1
		});
		surveyPath.setMap(map);
	};
}

function GetCenter(points)
{
	var maxLat = -90;
	var minLat = 90;
	var maxLng = -180;
	var minLng = 180;
	
	points.forEach(function(point) {
		if(point.lat > maxLat)
			maxLat = point.lat;
		else if(point.lat < minLat)
			minLat = point.lat;
		if(point.lng > maxLng)
			maxLng = point.lng;
		else if(point.lng < minLng)
			minLng = point.lng;
	});
	return {
		lat: (maxLat + minLat) / 2,
		lng: (maxLng + minLng) / 2
	};
}

function ChangeMapCenterByPointsAction(map)
{
	return function(points)
	{
		var center = GetCenter(points);
		map.setCenter(center);
	}
}

function MapSightingsToMapAction(map)
{
	return function(sightings){
		for(var i = 0;i < sightings.length;i++)
		{
			var marker = new google.maps.Marker({//Mark the sighting
				position: {lat: sightings[i].lat, lng: sightings[i].lng},
				map: map,
				title: sightings[i].number + " " + sightings[i].speciesCommon + "(s)"
			});
		}
	};
}